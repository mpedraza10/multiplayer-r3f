/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.15 public/models/hoodieCharacter.glb -o src/components/HoodieCharacter.jsx -r public
*/

// React imports
import { useEffect, useMemo, useRef, useState } from "react";

// React three fiber imports
import { useFrame, useGraph } from "@react-three/fiber";

// Drei imports
import { useGLTF, useAnimations, Html } from "@react-three/drei";

// Three stdlib imports
import { SkeletonUtils } from "three-stdlib";

// Import socket
import { socket } from "./SocketManager";

// Styles
import "./HoodieCharacter.css";

// Constant
const MOVEMENT_SPEED = 0.032;

export function HoodieCharacter({ id, ...props }) {
	// Chat states
	const [chatMessage, setChatMessage] = useState("");
	const [showChatBubble, setShowChatBubble] = useState(false);

	// Position
	const position = useMemo(() => props.position, []);

	// Group model reference
	const group = useRef();

	// Get everything from glb file
	const { scene, materials, animations } = useGLTF(
		"/models/hoodieCharacter.glb"
	);

	// Skinned meshes cannot be re-used in threejs without cloning them
	const clone = useMemo(() => SkeletonUtils.clone(scene), [scene]);

	// useGraph creates two flat object collections for nodes and materials
	const { nodes } = useGraph(clone);

	// Actions or animations from model
	const { actions } = useAnimations(animations, group);

	// Animation state
	const [animation, setAnimation] = useState("CharacterArmature|Idle");

	// Effect to change animations
	useEffect(() => {
		actions[animation].reset().fadeIn(0.32).play();

		// Cleanup (unmount)
		return () => actions[animation]?.fadeOut(0.32);
	}, [animation]);

	// Function to check for player actions
	useEffect(() => {
		let chatMessageBubbleTimeout;
		const onPlayerChatMessage = (value) => {
			if (value.id === id) {
				setChatMessage(value.message);
				clearTimeout(chatMessageBubbleTimeout);
				setShowChatBubble(true);
				chatMessageBubbleTimeout = setTimeout(() => {
					setShowChatBubble(false);
				}, 3500);
			}
		};

		// Call functions
		socket.on("playerChatMessage", onPlayerChatMessage);

		return () => {
			socket.off("playerChatMessage", onPlayerChatMessage);
		};
	}, []);

	// Frame to add logic to moving to another position
	useFrame(() => {
		if (group.current.position.distanceTo(props.position) > 0.1) {
			// Create the direction vector by subtratcting the new position to the current position
			const direction = group.current.position
				.clone()
				.sub(props.position)
				.normalize()
				.multiplyScalar(MOVEMENT_SPEED);

			// Now subtract the direction of the current position to get to the new position
			group.current.position.sub(direction);

			// Make the model look at the new position that is moving to
			group.current.lookAt(props.position);

			// Animate the moving to walk or run
			setAnimation("CharacterArmature|Run");
		} else {
			// Animate the moving to idle
			setAnimation("CharacterArmature|Idle");
		}
	});

	return (
		<group ref={group} {...props} position={position} dispose={null}>
			<Html position-y={2}>
				<div className="bubble">
					<p className={`bubble-content ${showChatBubble ? "" : "invisible"}`}>
						{chatMessage}
					</p>
				</div>
			</Html>
			<group name="Root_Scene">
				<group name="RootNode">
					<group
						name="CharacterArmature"
						rotation={[-Math.PI / 2, 0, 0]}
						scale={100}
					>
						<primitive object={nodes.Root} />
					</group>
					<group name="Casual_Feet" rotation={[-Math.PI / 2, 0, 0]} scale={100}>
						<skinnedMesh
							name="Casual_Feet_1"
							geometry={nodes.Casual_Feet_1.geometry}
							material={materials.White}
							skeleton={nodes.Casual_Feet_1.skeleton}
						/>
						<skinnedMesh
							name="Casual_Feet_2"
							geometry={nodes.Casual_Feet_2.geometry}
							material={materials.Purple}
							skeleton={nodes.Casual_Feet_2.skeleton}
						/>
					</group>
					<group name="Casual_Legs" rotation={[-Math.PI / 2, 0, 0]} scale={100}>
						<skinnedMesh
							name="Casual_Legs_1"
							geometry={nodes.Casual_Legs_1.geometry}
							material={materials.Skin}
							skeleton={nodes.Casual_Legs_1.skeleton}
						/>
						<skinnedMesh
							name="Casual_Legs_2"
							geometry={nodes.Casual_Legs_2.geometry}
							material={materials.LightBlue}
							skeleton={nodes.Casual_Legs_2.skeleton}
						>
							<meshStandardMaterial color={props.bottomColor} />
						</skinnedMesh>
					</group>
					<group name="Casual_Head" rotation={[-Math.PI / 2, 0, 0]} scale={100}>
						<skinnedMesh
							name="Casual_Head_1"
							geometry={nodes.Casual_Head_1.geometry}
							material={materials.Skin}
							skeleton={nodes.Casual_Head_1.skeleton}
						/>
						<skinnedMesh
							name="Casual_Head_2"
							geometry={nodes.Casual_Head_2.geometry}
							material={materials.Eyebrows}
							skeleton={nodes.Casual_Head_2.skeleton}
						/>
						<skinnedMesh
							name="Casual_Head_3"
							geometry={nodes.Casual_Head_3.geometry}
							material={materials.Eye}
							skeleton={nodes.Casual_Head_3.skeleton}
						/>
						<skinnedMesh
							name="Casual_Head_4"
							geometry={nodes.Casual_Head_4.geometry}
							material={materials.Hair}
							skeleton={nodes.Casual_Head_4.skeleton}
						>
							<meshStandardMaterial color={props.hairColor} />
						</skinnedMesh>
					</group>
					<group
						name="Casual_Body"
						position={[0, 0.007, 0]}
						rotation={[-Math.PI / 2, 0, 0]}
						scale={100}
					>
						<skinnedMesh
							name="Casual_Body_1"
							geometry={nodes.Casual_Body_1.geometry}
							material={materials.Purple}
							skeleton={nodes.Casual_Body_1.skeleton}
						>
							<meshStandardMaterial color={props.topColor} />
						</skinnedMesh>
						<skinnedMesh
							name="Casual_Body_2"
							geometry={nodes.Casual_Body_2.geometry}
							material={materials.Skin}
							skeleton={nodes.Casual_Body_2.skeleton}
						/>
					</group>
				</group>
			</group>
		</group>
	);
}

useGLTF.preload("/models/hoodieCharacter.glb");
